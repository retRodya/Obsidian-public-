###                             Принцип PECS
- Принцип PECS (Producer Extends Consumer Super) помогает понять, как использовать Wildcards (джокеры) в дженериках Java. PECS объясняет, когда использовать `extends` и `super` в дженериках, чтобы гарантировать безопасную работу с коллекциями.
###                   Основные концепции
1. **Инвариантность коллекций:** Коллекция, параметризованная классом `T`, принимает только объекты класса `T`.
2. **Коллекции хранят только ссылки**: В коллекциях хранятся только ссылки на объекты, а не сами объекты.
3. **Наследование**: Объект типа `T` может быть экземпляром класса `T` или его подкласса.
// Объект типа Animal 
```
		Animal myAnimal = new Animal(); 
		myAnimal.makeSound(); 
```
// Объект типа Animal может быть экземпляром класса Dog 	
```
		Animal myDog = new Dog(); 
		myDog.makeSound(); // Output: Bark }
```
##                     Синтаксис Wildcards
[[Wildcards]]
### - Инвариантный: `List<T>`
### - Ковариантный (Producer): `List<? extends T>`
- Список может содержать элементы типа `T` или его подтипов (например, `T1`).
- Список может быть параметризован типом `T` или его подтипами (`T1`).
- Можно получать элементы как тип `T`.
- Нельзя добавлять элементы, так как неизвестен точный тип. 
```
List<? extends Animal> animals = new ArrayList<Dog>(); // Корректно
List<? extends Animal> animals = new ArrayList<Cat>(); // Корректно
List<? extends Animal> animals = new ArrayList<Animal>(); // Корректно

// Получение элементов
Animal animal = animals.get(0); // Получение элементов как Animal
// Нельзя добавлять элементы, так как точный тип неизвестен
// animals.add(new Dog()); // Некорректно
```

```
List<? extends Animal> animals = new ArrayList<Dog>();

//Создается объект `ArrayList`, который будет содержать элементы типа `Dog`. Затем этот объект присваивается переменной `animals`, тип которой объявлен как `List<? extends Animal>`. Это означает, что `animals` может быть списком любых объектов, являющихся подклассами `Animal`. Такая запись позволяет работать с коллекцией, содержащей элементы любых типов, которые наследуются от `Animal`, но при этом вы не сможете добавлять новые элементы в эту коллекцию (кроме `null`), так как компилятор не может быть уверен в конкретном типе элементов.//
```
### - Контрвариантный (Consumer): `List<? super T>`
- Список может содержать элементы типа `T` или его подтипов (например, `T1`).
- Список может быть параметризован типом `T` или его супертипом (`Object`).
- Можно получать элементы только как тип `Object`, так как неизвестен точный тип, но можно с приведением типов.
- Можно добавлять элементы.
```
List<? super Dog> animals = new ArrayList<Animal>(); // Корректно List<? super Dog> animals = new ArrayList<Object>(); // Корректно 

// Добавление элементов 
animals.add(new Dog()); // Корректно 
animals.add(new SubDog()); // Корректно, где SubDog extends Dog 

// Получение элементов 
Object obj = animals.get(0); // Получение элементов как Object 
// Нельзя напрямую получить элемент типа Dog или Animal без приведения типов
```